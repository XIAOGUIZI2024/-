# 模板代码演示
```java
public int TwoPointSearchTemplateCode(int [] array , int target){  
    int left  = 0;  
    int right = array.length - 1;  
    while(right <= left){  
        int middle = (right + left) >>> 1;  
        if (array[middle] < target){  
            left = middle + 1;  
        } else if (target < array[middle]) {  
            right = middle - 1;  
        }else {  
            return middle;  
        }  
    }  
    return -1;  
}
```
* 为什么满足**right <= left** 
  假设 left 与 right 相等时，指定的值才是结果，如果没有相等这个条件，就会漏掉这个比较的情况
* 为什么是 **(right + left) >>> 1 这个向右移动 ，而不是 (right + left) / 2 这个操作**
  如果(right + left)相加的值如果超过**Integer.MAX_VALUE**就会为负数，而向右移动一个单位则不会应为符号位的存在也变成负数
# 二分查找平衡代码
**平衡版每次循环固定1次比较**
```java
public int TwoPointSearchBalanceCode(int [] arr , int target){  
    int i = 0,j = arr.length;  
    while (1 < j - i){  
        int m = (i + j) >>> 1;  
        if (target < arr[m]){  
            j = m;  
        }else{  
            i = m;  
        }  
    }  
    if (arr[i] == target){  
        return i;  
    }else{  
        return -1;  
    }  
}
```
# leftmost代码
**查找的目标值相同时在数组的最左侧出现**
```java
public int TwoPointSearchLeftMostCode(int [] array , int target){  
    int left  = 0;  
    int right = array.length - 1;  
    int candidate = -1;  
    while(right <= left){  
        int middle = (right + left) >>> 1;  
        if (array[middle] < target){  
            left = middle + 1;  
        } else if (target < array[middle]) {  
            right = middle - 1;  
        }else {  
            candidate = middle;  
            right = middle -1;  
        }  
    }  
    return candidate;  
}

// 优化版本
public int TwoPointSearchLeftMostCode(int [] array , int target){  
    int left  = 0;  
    int right = array.length - 1;   
    while(right <= left){  
        int middle = (right + left) >>> 1;  
        if (array[middle] < target){  
            left = middle + 1;  
        }else{
            //   
            right = middle - 1;  
        }
    }  
    return left;  
}
```
核心的思路是在找到结果的时候记录这个值的位置，右指针移动到这个指针的位置，继续进行二分查找
# rightmost代码
**查找的目标值相同时在数组的最右侧出现**
```java
public int TwoPointSearchRightMostCode(int [] array , int target){  
    int left  = 0;  
    int right = array.length - 1;  
    int candidate = -1;  
    while(right <= left){  
        int middle = (right + left) >>> 1;  
        if (array[middle] < target){  
            left = middle + 1;  
        } else if (target < array[middle]) {  
            right = middle - 1;  
        }else {  
            candidate = middle;  
            left = middle + 1;  
        }  
    }  
    return candidate;  
}
```
核心的思路是在找到结果的时候记录这个值的位置，左指针移动到这个指针的位置，继续进行二分查找