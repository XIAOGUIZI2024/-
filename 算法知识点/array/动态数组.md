```java

import java.util.function.Consumer;  
  
/**  
 * @InterfaceName: DynamicArray  
 * @Description: 动态数组的开发  
 * @Author: YourName  
 * @Date: 2026/2/2  
 */public class DynamicArray<E> {  
  
    private Object[] data;      // 存储元素的内部数组  
    private int size;           // 当前元素个数  
    private int capacity;       // 当前容量  
  
    // 构造方法  
    public DynamicArray() {  
        this.capacity = 16;     // 默认初始容量  
        this.data = new Object[capacity];  
        this.size = 0;  
    }  
  
    public DynamicArray(int initialCapacity) {  
        if (initialCapacity <= 0) {  
            throw new IllegalArgumentException("初始容量必须大于0");  
        }  
        this.capacity = initialCapacity;  
        this.data = new Object[capacity];  
        this.size = 0;  
    }  
  
    /**  
     * 获取数组的存储当前元素个数  
     * @return size  
     */    public int size() {  
        return size;  
    }  
  
    /**  
     * 判断数组是否是空的  
     * @return  
     */  
    public boolean isEmpty() {  
        return size == 0;  
    }  
  
    /**  
     * 获取数组的容量  
     * @return 返回的是数组的容量值  
     */  
    public int getCapacity(){  
        return capacity;  
    }  
  
    /**  
     * 在数组的末端添加元素  
     * @param element  
     */  
    public void add(E element){  
        // 先扩建添加一个单位的容量进行判断  
        ensureCapacity(size + 1);  
        data[++size] = element;  
    }  
  
    /**  
     * 在指定的位置添加元素  
     * @param index  
     * @param element  
     */  
    public void add(int index, E element) {  
        // 检查索引合法性  
        if (index < 0 || index > size) {  
            throw new IndexOutOfBoundsException("索引越界: " + index);  
        }  
        ensureCapacity(size + 1);  
  
        // 将index位置及之后的元素向后移动一位  
        if (size - index > 0) {  
            System.arraycopy(data, index, data, index + 1, size - index);  
        }  
        data[index] = element;  
        size++;  
    }  
    /**  
     * lambda 遍历数组进行操作  
     */  
    public void forEach(Consumer<E> action){  
        for (int i = 0;i < size;i++){  
            @SuppressWarnings("unchecked")  
            E element = (E) data[i];  
            action.accept(element);  
        }  
    }  
  
    @SuppressWarnings("unchecked")  
    public E get(int index) {  
        if (index < 0 || index >= size) {  
            throw new IndexOutOfBoundsException("索引越界: " + index);  
        }  
        return (E) data[index];  
    }  
  
    public E set(int index, E element) {  
        if (index < 0 || index >= size) {  
            throw new IndexOutOfBoundsException("索引越界: " + index);  
        }  
        E oldValue = get(index);  
        data[index] = element;  
        return oldValue;  
    }  
  
    public E remove(int index) {  
        if (index < 0 || index >= size) {  
            throw new IndexOutOfBoundsException("索引越界: " + index);  
        }  
        E removedElement = get(index);  
        // 计算需要移动的元素数量  
        int numMoved = size - index - 1;  
        if (numMoved > 0) {  
            System.arraycopy(data, index + 1, data, index, numMoved);  
        }  
  
        // 清空最后一个位置的引用，避免内存泄漏  
        data[--size] = null;  
        return removedElement;  
    }  
    public boolean remove(Object obj) {  
        for (int i = 0; i < size; i++) {  
            if (obj == null ? data[i] == null : obj.equals(data[i])) {  
                remove(i);  
                return true;  
            }  
        }  
        return false;  
    }  
  
    public void clear() {  
        // 只清除实际使用的部分，避免遍历整个capacity  
        for (int i = 0; i < size; i++) {  
            data[i] = null;  
        }  
        size = 0;  
        // 可选：如果希望完全重置  
        // data = new Object[capacity];  
    }  
  
    private void ensureCapacity(int minCapacity){  
        if (minCapacity > capacity){  
            // 确保 capacity 非负  
            if (capacity < 0) {  
                throw new IllegalStateException("Capacity cannot be negative: " + capacity);  
            }  
            // 这个地方不可以 >>> 1 ,要带符号右移动 既是 >> 1, capacity可能为负数，则 >>1 后得到可能是一个很大的正整数  
            // 默认是扩展为原来的 1.5 倍的容量  
            int newCapacity = capacity + (capacity >> 1);  
            if (newCapacity < minCapacity){  
                newCapacity = minCapacity;  
            }  
            Object[] newData = new Object[newCapacity];  
            System.arraycopy(data, 0, newData, 0, size);  
            data = newData;  
            capacity = newCapacity;  
        }  
    }  
  
  
}
```