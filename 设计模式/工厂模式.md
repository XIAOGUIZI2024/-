# 简单工厂模式（Simple Factory）

严格来说，它不是一个标准的设计模式，更像是一种编程习惯，但非常常用。

**目的**：定义一个工厂类，根据传入的参数不同，返回不同类的实例。这些被创建的类通常有一个共同的父类或接口。

**结构**：

- **抽象产品**：定义了产品的接口。
    
- **具体产品**：实现抽象产品接口的具体类。
    
- **简单工厂**：负责创建所有具体产品的实例。

**示例（生产鼠标）**：
```java

// 1. 抽象产品
interface Mouse {
    void click();
}

// 2. 具体产品
class DellMouse implements Mouse {
    @Override
    public void click() { System.out.println("Dell mouse clicks."); }
}
class HpMouse implements Mouse {
    @Override
    public void click() { System.out.println("HP mouse clicks."); }
}

// 3. 简单工厂
class MouseFactory {
    // 核心：根据参数创建不同对象
    public static Mouse createMouse(String brand) {
        if ("Dell".equalsIgnoreCase(brand)) {
            return new DellMouse();
        } else if ("HP".equalsIgnoreCase(brand)) {
            return new HpMouse();
        }
        throw new IllegalArgumentException("Unknown brand");
    }
}

// 4. 客户端使用
public class Client {
    public static void main(String[] args) {
        Mouse mouse = MouseFactory.createMouse("Dell");
        mouse.click(); // 输出：Dell mouse clicks.
    }
}

**优点**：客户端与具体产品类解耦。  
**缺点**：违背“开闭原则”，新增产品需要修改工厂方法。
```
---
# 工厂方法模式（Factory Method）

**目的**：定义一个用于创建对象的接口（工厂接口），但让子类决定实例化哪一个具体产品类。工厂方法使一个类的实例化延迟到其子类。

**结构**：

- **抽象工厂**：声明工厂方法，返回抽象产品。
    
- **具体工厂**：实现工厂方法，返回具体产品。
    
- **抽象产品**：定义产品接口。
    
- **具体产品**：实现产品接口。

**示例（生产不同品牌的鼠标）**：
```java
// 1. 抽象产品
interface Mouse {
    void click();
}

// 2. 具体产品
class DellMouse implements Mouse {
    @Override public void click() { System.out.println("Dell mouse clicks."); }
}
class HpMouse implements Mouse {
    @Override public void click() { System.out.println("HP mouse clicks."); }
}

// 3. 抽象工厂
interface MouseFactory {
    Mouse createMouse(); // 工厂方法
}

// 4. 具体工厂（每个产品对应一个工厂）
class DellMouseFactory implements MouseFactory {
    @Override
    public Mouse createMouse() {
        return new DellMouse();
    }
}
class HpMouseFactory implements MouseFactory {
    @Override
    public Mouse createMouse() {
        return new HpMouse();
    }
}

// 5. 客户端使用
public class Client {
    public static void main(String[] args) {
        // 需要哪个品牌，就使用对应的工厂
        MouseFactory factory = new DellMouseFactory();
        Mouse mouse = factory.createMouse();
        mouse.click(); // 输出：Dell mouse clicks.
    }
}

**优点**：

- 完全符合“开闭原则”。新增产品时，只需增加新的具体工厂类，无需修改原有代码。
    
- 客户端只依赖抽象工厂和抽象产品，耦合度低。
    

**缺点**：每增加一个产品，就需要增加一个具体工厂类，导致类数量增多，系统变复杂。
```
---

# 抽象工厂模式（Abstract Factory）

**目的**：提供一个创建**一系列相关或相互依赖对象**的接口，而无需指定它们具体的类。

**结构**：

- **抽象工厂**：声明一组用于创建一族产品的方法。
    
- **具体工厂**：实现抽象工厂的方法，创建一族具体产品。
    
- **抽象产品**：为每种产品声明接口。
    
- **具体产品**：实现抽象产品接口，定义被具体工厂创建的产品。
    

**示例（生产整套电脑外设：鼠标 + 键盘）**：
```java
// ------ 抽象产品族 ------
interface Mouse {
    void click();
}
interface Keyboard {
    void press();
}

// ------ 具体产品（Dell系列）------
class DellMouse implements Mouse {
    @Override public void click() { System.out.println("Dell mouse clicks."); }
}
class DellKeyboard implements Keyboard {
    @Override public void press() { System.out.println("Dell keyboard pressed."); }
}

// ------ 具体产品（HP系列）------
class HpMouse implements Mouse {
    @Override public void click() { System.out.println("HP mouse clicks."); }
}
class HpKeyboard implements Keyboard {
    @Override public void press() { System.out.println("HP keyboard pressed."); }
}

// ------ 抽象工厂 ------
interface PcFactory {
    Mouse createMouse();
    Keyboard createKeyboard();
}

// ------ 具体工厂（Dell工厂生产Dell全套外设）------
class DellFactory implements PcFactory {
    @Override public Mouse createMouse() { return new DellMouse(); }
    @Override public Keyboard createKeyboard() { return new DellKeyboard(); }
}

// ------ 具体工厂（HP工厂生产HP全套外设）------
class HpFactory implements PcFactory {
    @Override public Mouse createMouse() { return new HpMouse(); }
    @Override public Keyboard createKeyboard() { return new HpKeyboard(); }
}

// ------ 客户端 ------
public class Client {
    public static void main(String[] args) {
        // 选择一套品牌（一个产品族）
        PcFactory factory = new DellFactory();
        
        // 创建该品牌的一系列产品
        Mouse mouse = factory.createMouse();
        Keyboard keyboard = factory.createKeyboard();
        
        mouse.click();
        keyboard.press();
        // 输出：
        // Dell mouse clicks.
        // Dell keyboard pressed.
    }
}
```

**优点**：

- 保证客户端始终只使用同一个产品族中的对象。
    
- 产品族内的约束对客户端透明，更换产品族非常方便。


**缺点**：

- 难以支持**新增产品种类**（例如，想增加“耳机”这个新产品）。这需要修改所有工厂接口和类，违反“开闭原则”。但它非常擅长支持**新增产品族**。
    

---

### 总结与对比

|模式|核心思想|解决的问题|优点|缺点|
|---|---|---|---|---|
|**简单工厂**|一个“万能”工厂，根据参数创建对象。|对象创建逻辑集中管理，客户端与产品解耦。|结构简单，易于实现。|违背开闭原则，新增产品需修改工厂。|
|**工厂方法**|**每个产品**对应一个**工厂**。将实例化推迟到子类。|避免if-else分支判断，支持新增产品而不修改客户端。|完全符合开闭原则，扩展性好。|类数量爆炸（一个产品一个工厂）。|
|**抽象工厂**|**每个产品族**对应一个**工厂**，创建**一系列相关**对象。|创建一整族对象，并保证它们兼容。|隔离具体类，保证产品族一致性。|难以扩展新的产品种类（需大改）。|

### 如何选择？

- 如果产品种类固定，且创建逻辑不复杂 → **简单工厂**。
    
- 如果预计产品种类会频繁增加，且设计初期无法确定所有具体类型 → **工厂方法**。
    
- 如果需要创建的不是单个产品，而是**一整套相关联、有约束的产品**（如不同风格的UI组件、不同生态的硬件） → **抽象工厂**。
    

工厂模式是理解“面向接口编程”和“依赖倒置原则”的绝佳范例，它通过封装变化点（对象的创建），让系统更加灵活和稳定。