# RabbitMQ
## RabbitMQ 术语
* 生成者 **P** ：发送信息
* 队列：存储要处理信息的地方
* 消费者 **C** ：处理信息
* 消息代理：存储队列的地方
* 交换器：接收生产者发送的信息，把信息转发到相应的队列存储

### java入门例子
#### 生产者 发送信息
``` java
import com.rabbitmq.client.ConnectionFactory;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.Channel;

public class Send {
命名队列  
private final static String QUEUE_NAME = "hello";  
public static void main(String[] argv) throws Exception {  
...  
}  
//创建一个到服务器的连接
ConnectionFactory factory = new ConnectionFactory();
// 连接 RabbitMQ 节点  
factory.setHost("localhost");  
try (Connection connection = factory.newConnection();  
Channel channel = connection.createChannel()) {
声明一个要发送到的队列  
channel.queueDeclare(QUEUE_NAME, false, false, false, null);
// 发送连接  
String message = "Hello World!";  
channel.basicPublish("", QUEUE_NAME, null, message.getBytes());  
System.out.println(" [x] Sent '" + message + "'");
}

}

``` 
#### 消费者处理信息
```java
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
import com.rabbitmq.client.DeliverCallback;
public class Recv {  
  
private final static String QUEUE_NAME = "hello";  
  
public static void main(String[] argv) throws Exception {  
ConnectionFactory factory = new ConnectionFactory();  
factory.setHost("localhost");  
Connection connection = factory.newConnection();  
Channel channel = connection.createChannel();  
// 确保与发布到的队列相匹配
channel.queueDeclare(QUEUE_NAME, false, false, false, null);  
System.out.println(" [*] Waiting for messages. To exit press CTRL+C");  

// 回调函数给队列已经处理了消息了  
DeliverCallback deliverCallback = (consumerTag, delivery) -> {  
String message = new String(delivery.getBody(), "UTF-8");  
System.out.println(" [x] Received '" + message + "'");  
}; 
 
channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });
}  
}

```
### 工作队列
* 轮询分发：队列会轮询分法信息给消费者，也就是说消费者会轮流消费信息
* 消息确认：消费者处理完信息返回给RabbitMQ，RabbitMQ就会确认安全删除信息，否则RabbitMQ 将理解消息未完全处理，并会将其重新排队
* 消息持久化： RabbitMQ 将消息保存到磁盘
* 公平分派：合理的处理队列分发轻重不一的任务
### 发布/订阅
**队列把一条信息发送给多个消费者进行处理**
**交换器**
* 一方面，它接收来自生产者的消息；另一方面，它将消息推送到队列
* 交换器的类型：direct topic headers fanout
* 使用交换器的语法:
```java
创建交换器
channel.exchangeDeclare("logs", "fanout");
使用交换器
channel.basicPublish( "logs", "", null, message.getBytes());
```
**临时队列**
* 临时创建使用，使用完就删掉
* 创建语法
```java
String queueName = channel.queueDeclare().getQueue();
```
**绑定**
* 把交换器和队列进行绑定
* 绑定的语法
```java
channel.queueBind(queueName, "logs", "");
```

