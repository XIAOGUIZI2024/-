# RabbitMQ
## RabbitMQ 术语
* 生成者 **P** ：发送信息
* 队列：存储要处理信息的地方
* 消费者 **C** ：处理信息
* 消息代理：存储队列的地方

### java入门例子
#### 生产者 发送信息
``` java
import com.rabbitmq.client.ConnectionFactory;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.Channel;

public class Send {
命名队列  
private final static String QUEUE_NAME = "hello";  
public static void main(String[] argv) throws Exception {  
...  
}  
//创建一个到服务器的连接
ConnectionFactory factory = new ConnectionFactory();
// 连接 RabbitMQ 节点  
factory.setHost("localhost");  
try (Connection connection = factory.newConnection();  
Channel channel = connection.createChannel()) {
声明一个要发送到的队列  
channel.queueDeclare(QUEUE_NAME, false, false, false, null);
// 发送连接  
String message = "Hello World!";  
channel.basicPublish("", QUEUE_NAME, null, message.getBytes());  
System.out.println(" [x] Sent '" + message + "'");
}

}

``` 
#### 消费者处理信息
```java
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
import com.rabbitmq.client.DeliverCallback;
public class Recv {  
  
private final static String QUEUE_NAME = "hello";  
  
public static void main(String[] argv) throws Exception {  
ConnectionFactory factory = new ConnectionFactory();  
factory.setHost("localhost");  
Connection connection = factory.newConnection();  
Channel channel = connection.createChannel();  
// 确保与发布到的队列相匹配
channel.queueDeclare(QUEUE_NAME, false, false, false, null);  
System.out.println(" [*] Waiting for messages. To exit press CTRL+C");  

// 回调函数给队列已经处理了消息了  
DeliverCallback deliverCallback = (consumerTag, delivery) -> {  
String message = new String(delivery.getBody(), "UTF-8");  
System.out.println(" [x] Received '" + message + "'");  
}; 
 
channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });
}  
}

```
### 工作队列
* 轮询分发：队列会轮询分法信息给消费者，也就是说消费者会轮流消费信息
* 消息确认：消费者处理完信息返回给