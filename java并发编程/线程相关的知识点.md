# 守护线程
**守护线程**是Java中的一种特殊线程，它的**生命周期依赖于其他线程**。当所有**用户线程（非守护线程）** 都结束时，守护线程会自动被JVM终止。
## 代码演示
```java
public class ThreadDaemon {  
    public static void main(String[] args) {  
        Thread thread = new Thread(new DaemonThread(),"Daemon");  
        // 开始守护线程  
        thread.setDaemon(true);  
        thread.start();  
        try {  
            System.out.println("主线程等待6秒...");  
            Thread.sleep(4000);  // 等待6秒（比守护线程的5秒长）  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
   static class DaemonThread implements Runnable{  
       @Override  
       public void run() {  
           try {  
               Thread.sleep(5000);  
           }catch (InterruptedException e){  
               e.printStackTrace();  
           }finally {  
               System.out.println("出现错误");  
           }  
       }  
   }  
}
```
## **重要注意事项**
### 1. **设置时机必须正确**

```java
// ✅ 正确：启动前设置
thread.setDaemon(true);
thread.start();

// ❌ 错误：启动后设置（抛出IllegalThreadStateException）
thread.start();
thread.setDaemon(true);  // 运行时异常！
```
### 2. **finally块不保证执行**

```java
Thread daemon = new Thread(() -> {
    try {
        // 执行一些操作
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // ❌ 当JVM退出时，这个finally块可能不会执行！
        cleanup();  // 资源可能无法清理
        System.out.println("这个输出可能看不到");
    }
});
daemon.setDaemon(true);
daemon.start();
```
### 3. **不要用于重要资源管理**
```java
// ❌ 错误用法：守护线程管理文件
Thread fileWriter = new Thread(() -> {
    try (FileWriter writer = new FileWriter("data.txt")) {
        writer.write("重要数据");
        writer.flush();
        // 如果JVM突然退出，数据可能丢失
    } catch (IOException e) {
        e.printStackTrace();
    }
});
fileWriter.setDaemon(true);  // 危险！数据可能丢失
```
### 4. **子线程不继承守护属性**

```java
Thread parent = new Thread(() -> {
    // 父线程是守护线程
    Thread child = new Thread(() -> {
        System.out.println("子线程是否是守护线程: " + 
                          Thread.currentThread().isDaemon());  // false
    });
    child.start();
});
parent.setDaemon(true);
parent.start();