# **什么是线程优先级？**

**线程优先级**是一个整数值（1-10），用于向线程调度器**建议**线程执行的相对重要性。**注意：这只是一个提示，不保证执行顺序！**

# **优先级常量**

```java
public class ThreadPriorityDemo {
    public static void main(String[] args) {
        // Java定义的三个标准优先级常量
        System.out.println("最低优先级: " + Thread.MIN_PRIORITY);     // 1
        System.out.println("默认优先级: " + Thread.NORM_PRIORITY);    // 5
        System.out.println("最高优先级: " + Thread.MAX_PRIORITY);     // 10
    }
}
```

# **设置和获取优先级**

```java
public class PriorityBasic {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            System.out.println("当前线程优先级: " + 
                Thread.currentThread().getPriority());
        });
        
        // 获取默认优先级
        System.out.println("默认优先级: " + thread.getPriority());  // 5
        
        // 设置优先级
        thread.setPriority(8);
        System.out.println("设置后优先级: " + thread.getPriority());  // 8
        
        thread.start();
    }
}
```
# **优先级继承规则**

### 线程继承创建它的线程的优先级：

```java
public class PriorityInheritance {
    public static void main(String[] args) {
        // 主线程设置高优先级
        Thread.currentThread().setPriority(8);
        System.out.println("主线程优先级: " + 
            Thread.currentThread().getPriority());  // 8
        
        // 新线程继承主线程优先级
        Thread child = new Thread(() -> {
            System.out.println("子线程优先级: " + 
                Thread.currentThread().getPriority());  // 8
        });
        
        System.out.println("子线程初始优先级: " + child.getPriority());  // 8
        child.start();
    }
}
```
## 在线程池中设置优先级：

```java
import java.util.concurrent.*;

public class ThreadPoolPriority {
    public static void main(String[] args) {
        // 创建带优先级的线程工厂
        ThreadFactory priorityFactory = new ThreadFactory() {
            private int priority = Thread.NORM_PRIORITY;
            
            public ThreadFactory withPriority(int priority) {
                this.priority = priority;
                return this;
            }
            
            @Override
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r);
                t.setPriority(priority);
                return t;
            }
        };
        
        ExecutorService executor = Executors.newFixedThreadPool(
            2, 
            priorityFactory.withPriority(Thread.MAX_PRIORITY)
        );
        
        executor.submit(() -> {
            System.out.println("线程优先级: " + 
                Thread.currentThread().getPriority());  // 10
        });
        
        executor.shutdown();
    }
}
```
## **优先级的影响（演示）**

### 优先级对CPU时间的影响示例：

```java
public class PriorityEffectDemo {
    static class Counter implements Runnable {
        private final String name;
        private long count = 0;
        private volatile boolean running = true;
        
        public Counter(String name) {
            this.name = name;
        }
        
        @Override
        public void run() {
            while (running) {
                count++;
            }
            System.out.println(name + " 计数: " + count);
        }
        
        public void stop() {
            running = false;
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        Counter highPriorityCounter = new Counter("高优先级");
        Counter lowPriorityCounter = new Counter("低优先级");
        
        Thread high = new Thread(highPriorityCounter, "High-Priority");
        Thread low = new Thread(lowPriorityCounter, "Low-Priority");
        
        // 设置不同优先级
        high.setPriority(Thread.MAX_PRIORITY);     // 10
        low.setPriority(Thread.MIN_PRIORITY);      // 1
        
        System.out.println(high.getName() + " 优先级: " + high.getPriority());
        System.out.println(low.getName() + " 优先级: " + low.getPriority());
        
        high.start();
        low.start();
        
        // 运行5秒
        Thread.sleep(5000);
        
        highPriorityCounter.stop();
        lowPriorityCounter.stop();
        
        high.join();
        low.join();
        
        // 注意：结果可能因操作系统和JVM实现而异
        System.out.println("=========================");
        System.out.println("高优先级计数: " + highPriorityCounter.count);
        System.out.println("低优先级计数: " + lowPriorityCounter.count);
    }
}
```
# **重要注意事项**

### 1. **优先级只是建议，不保证执行顺序**

```java
public class NoGuaranteeDemo {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("演示：优先级不保证执行顺序\n");
        
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            Thread t = new Thread(() -> {
                System.out.println("任务 " + taskId + " 执行");
            });
            
            // 交替设置高低优先级
            if (taskId % 2 == 0) {
                t.setPriority(Thread.MAX_PRIORITY);
                System.out.println("任务 " + taskId + " 设置为高优先级");
            } else {
                t.setPriority(Thread.MIN_PRIORITY);
                System.out.println("任务 " + taskId + " 设置为低优先级");
            }
            
            t.start();
        }
        
        Thread.sleep(1000);
    }
}
```
### 2. **不同操作系统的差异**
```java
public class PlatformDifferences {
    public static void main(String[] args) {
        // Windows: 严格优先级（1-10）
        // Linux: 可能映射到不同的nice值
        // macOS: 优先级处理方式不同
        
        System.out.println("当前操作系统: " + System.getProperty("os.name"));
        System.out.println("Java优先级范围: 1-10");
        System.out.println("实际效果因操作系统而异");
    }
}
```
### 3. **优先级反转问题**

```java
public class PriorityInversion {
    private static final Object lock = new Object();
    
    public static void main(String[] args) throws InterruptedException {
        // 低优先级线程先获取锁
        Thread low = new Thread(() -> {
            synchronized (lock) {
                System.out.println("低优先级线程获取锁");
                try {
                    Thread.sleep(5000);  // 长时间持有锁
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("低优先级线程释放锁");
            }
        });
        low.setPriority(Thread.MIN_PRIORITY);
        
        // 高优先级线程等待锁
        Thread high = new Thread(() -> {
            synchronized (lock) {
                System.out.println("高优先级线程获取锁");
            }
        });
        high.setPriority(Thread.MAX_PRIORITY);
        
        low.start();
        Thread.sleep(100);  // 确保低优先级先启动
        
        high.start();
        
        // 高优先级线程被低优先级阻塞 - 优先级反转
        high.join();
        low.join();
    }
}